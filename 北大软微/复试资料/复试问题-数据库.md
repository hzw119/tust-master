1. 一二三数据库范式

   **NF(范式)**:符合某一种级别的关系模式的集合。说白了就是一张数据表的表结构所符合的设计标准的级别。

   **函数依赖**:若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y

   **部分函数依赖**：x->y, $x`$为x的真子集，存在$x`$ 能推出y，则y对x为**部分函数依赖**

   **完全函数依赖**：x->y, $x`$为x的真子集，任何$x`$ 都不能推出y，则y对x为**完全函数依赖**

   传递函数依赖：x->y，y->z==>x->z

   **什么是候选码/主码/码？**

   关系中的某个属性或者某几个属性的组合，用于区分每个元组，称为**候选码**。所谓“区分元组”，就是指当一个元组的候选码确定了，则元组中的其他属性也就确定了，且不同元组的候选码一定是不同的！如果一个元组有多个候选码，则一般选取其中一个作为**主码**。在使用中，常常把候选码和主码都简称为码。此外，**包含在码中的属性称为主属性，不包含在码中的属性称为非主属性**。

   1. 第一范式：符合1NF的关系中的每个属性都不可再分、不可重复 ==> 属性的原子性。
   
   2. 第二范式:  要求数据库的每个实例或行必须可以被唯一的区分==>  非主属性完全依赖于码。
   
   3. 第三范式：不存在**非主属性**对**码**的**传递依赖**
   
       学生表：学号，系号、系主任名、年龄
   
         学号是码，系主任名是非主属性，
   
      学号->系号->系主任名 此时存在非主属性对码的传递依赖，当系主任人选更换时，则需要更新学生表，造成信息冗余
   
   4. BC范式：符合3NF,不存在**主属性**对**码**的部分依赖和传递依赖。（主属性不部分依赖、不传递依赖）
   
      符合3NF要求的数据库设计，基本解决了数据冗余、更新复杂、插入异常、删除异常的不足。
      
      BC范式
      
      货物表：
      
      货物编号、货物数量、仓库号、仓库管理员
      
      仓库号对应一个唯一的仓库管理员
      
      货物编号对应唯一货物
      
      货物编号->仓库编号->仓库管理员
   
2. 能不能无限插入数据
   **当然不能**，因为操作系统支持的单个文件大小是有限的，而数据库支持的数据文件数量是有限的，所以数据库的容量不是无限的。

3. 大量数据插入的优化手段

   1. 分表：**依据业务规则拆分成不同的细表**

   2. 先删除索引，后创建索引（插入时会一直更新索引）

   3. **少提交**，减少I/O操作，**事务**

   4. 多线程

      **问题**：100个数据和1万个数据插入有什么区别

      看看是否有**索引**，如果有，**插入数据量**大，索引更新代价高，可以先**删除索引**再**新建**
   
4. **查询的优化**

   1. 外键建索引
   2. 查询命令优化

   **笛卡尔积**：**排列组合的问题**

   左连接：左表的全部和右表的部分通过某键值连接

   右连接：右表的全部和左表的部分通过某键值连接

   内连接：显示左右两表共有的

5. **存储过程**：**预编译**的SQL语句，有**参数**的函数

6. 索引包括哪些字段
   1. 表的主键，外键必须有索引
   2. 经常出现在**Where**子句中的字段，特别是大表的字段
   3. 索引应该建在**小**字段。
   4. 经常与其他表进行**连接**，在连接字段上应该建立索引

   **什么是索引**：索引是一种对**数据库表中一列或多列的值**进行**排序**的**存储**结构。

   **什么是主键**：指的是一个列或多列的组合，其**值能唯一地标识表中的每一行**，通过它可强制表的**实体完整性**。

   **主键**的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。

   索引类型：

     唯一索引/不唯一索引：  

     主键索引：

     **聚集索引**:**索引项的顺序**与表中记录的**物理顺序**一致，只能有一个聚集索引

     **非聚集索引**：就是给普通字段加上索引，在普通字段上建立索引表

   和非聚集索引相比，聚集索引的查找速度更快

7. **事务**

   事务是**访问并可能更新数据库中各种数据项**的一个**程序执行单元**，

   事务特征：

   1. 原子性，要不都做，要不都不做
   2. 一致性
   3. 隔离性
   4. 持久性，一旦改变，则改变是永久的不可恢复

   **事务的隔离级别**：多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰。

    **并发遇到的问题**：脏读（之前的更新事务**未提交**但是被读）、幻读（在查询的同一时间的**插入**，两次读取出现结果不一致）、不可重复读(读的同时**修改**，在读一次，两次读的结果不一样)、丢失修改

   1. 读未提交：可以读到未提交的
   2. **读提交**（Oracle）：只能读到已经提交了的内容：避免脏读
   3. 可重复读(Repeated Read)（MYSql）：当查询事务启动时，修改事务不允许进行
   4. 串行化(Serializable):

   MySQL使用MVCC（多版本并发控制）的策略来实现的事务之间的隔离，用于实现**提交读、可重复读**这两种隔离级别。

   MVCC 规定只能读取**已经提交的**快照。

8. 视图：从一个**表或多个表**导出的**虚拟的表**，其内容由查询定义。

   

9. 数据库的三种**数据模型**

   1. 层状模型：数据结构是一棵**有向树**，北大的各个学院，各个学院的各个系。
   2. 网状模型：网状模型以**网状结构**表示实体与实体之间的联系。
   3. 关系模型：关系模型以**二维表结构**来表示实体与实体之间的联系。

   

10. 数据库的约束

    1. **主键**约束: 唯一性，非空性

    2. **唯一**约束：唯一性，可以空，但只能有一个

    3. 检查约束：对于该列数据的范围、格式的限制

    4. **外键**约束：

11. 设计数据库时需要注意问题

    1. 主键
    2. 索引
    3. 范式

## SQL语句

1. having vs. where

   1. where 是从数据表中的字段**直接进行筛选**，having是从前面筛选的字段**再筛选**

   2. having子句可以使用字段别名，而where不能使用
   3. having可以先使用统计函数，先分组，在判断。

2. group by 子句用来分组where子句的输出

3. 在查询过程中聚合语句(sum,min,max,avg,count)要比having子句**优先**执行.而where子句在查询过程中执行优先级别**优先于**聚合语句(sum,min,max,avg,count)。

4. 查询执行顺序：

   SELECT.....From....WHERE

   GROUP BY .....HAVING

   ORDER BY ......LIMIT

